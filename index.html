<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI Driving Assistant v6.0 (Mobile)</title>
    <!-- Load TensorFlow.js and Coco-SSD -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
    <style>
        body {
            margin: 0;
            background-color: #000;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            color: white;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 1;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            text-align: center;
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #444;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #333;
            border-top: 4px solid #00d2ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        button {
            background: #00d2ff;
            color: #000;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            font-weight: bold;
            border-radius: 25px;
            cursor: pointer;
            margin-top: 10px;
        }

        #debug {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 20;
            font-size: 10px;
            color: lime;
            pointer-events: none;
        }
    </style>
</head>
<body>

<div id="container">
    <video id="video" playsinline muted></video>
    <canvas id="hud"></canvas>
    
    <div id="loading">
        <div class="spinner"></div>
        <h3 id="statusText">Initializing AI...</h3>
        <p style="color: #aaa; font-size: 12px; margin-bottom: 15px;">Requires Camera Access</p>
        <button id="startBtn" style="display:none">START SYSTEM</button>
    </div>
    
    <div id="debug"></div>
</div>

<script>
    // Configuration
    const CONFIG = {
        CONFIDENCE_THRESHOLD: 0.45, // Higher for mobile to reduce noise
        DANGER_ZONE_WIDTH: 0.35,    // Center 35% of screen
        CRITICAL_AREA: 0.20,        // Area % to trigger critical warning
        HIGH_AREA: 0.10,
        MEDIUM_AREA: 0.04
    };

    // Colors
    const COLORS = {
        CYAN: '#00d2ff',
        GREEN: '#64e664',
        YELLOW: '#ffe664',
        ORANGE: '#ffb450',
        RED: '#ff5050',
        WHITE: '#ffffff',
        GRAY: 'rgba(128, 128, 128, 0.5)',
        BLACK_BG: 'rgba(0, 0, 0, 0.6)'
    };

    // State
    let model = null;
    let isRunning = false;
    let video = document.getElementById('video');
    let canvas = document.getElementById('hud');
    let ctx = canvas.getContext('2d');
    let startBtn = document.getElementById('startBtn');
    let statusText = document.getElementById('statusText');
    let loadingDiv = document.getElementById('loading');
    
    // Smooth instruction state
    let currentInstruction = {
        main: "READY",
        sub: "System Online",
        color: COLORS.CYAN
    };

    // FPS Calculation
    let lastFrameTime = 0;
    let fps = 0;

    // --- initialization ---

    async function init() {
        try {
            statusText.innerText = "Loading Model...";
            // Load Coco-SSD (Lightweight version of YOLO logic)
            model = await cocoSsd.load({ base: 'lite_mobilenet_v2' });
            
            statusText.innerText = "System Ready";
            document.querySelector('.spinner').style.display = 'none';
            startBtn.style.display = 'inline-block';
            
            startBtn.addEventListener('click', startCamera);
        } catch (err) {
            statusText.innerText = "Error Loading AI";
            console.error(err);
            alert("Failed to load AI model. Make sure you are online.");
        }
    }

    async function startCamera() {
        statusText.innerText = "Accessing Camera...";
        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: {
                    facingMode: 'environment',
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                },
                audio: false
            });
            
            video.srcObject = stream;
            
            video.onloadedmetadata = () => {
                video.play();
                loadingDiv.style.display = 'none';
                resizeCanvas();
                isRunning = true;
                requestAnimationFrame(loop);
            };
        } catch (err) {
            console.error(err);
            alert("Camera access denied or failed. Please check permissions and ensure you are using HTTPS.");
            statusText.innerText = "Camera Error";
        }
    }

    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }

    window.addEventListener('resize', resizeCanvas);

    // --- Core Logic ---

    async function loop(timestamp) {
        if (!isRunning) return;

        // Calculate FPS
        const delta = timestamp - lastFrameTime;
        fps = 1000 / delta;
        lastFrameTime = timestamp;

        // 1. Detect Objects
        // We only look for traffic related classes
        const predictions = await model.detect(video, 5, CONFIG.CONFIDENCE_THRESHOLD);
        
        const relevantClasses = ['person', 'bicycle', 'car', 'motorcycle', 'bus', 'truck', 'dog', 'horse', 'sheep', 'cow'];
        const detections = predictions.filter(p => relevantClasses.includes(p.class));

        // 2. Clear & Draw Video Frame (if needed, but video element is behind)
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // 3. Analyze Scene
        const analysis = analyzeScene(detections);
        updateInstruction(analysis);

        // 4. Render HUD
        drawRoadOverlay();
        drawDetections(detections);
        drawHUD(analysis);

        requestAnimationFrame(loop);
    }

    function analyzeScene(detections) {
        const width = canvas.width;
        const height = canvas.height;
        const area = width * height;
        
        let maxThreat = 0; // 0: None, 1: Low, 2: Med, 3: High, 4: Critical
        let criticalObj = null;

        // Determine Center Zone
        const centerLeft = width * (0.5 - CONFIG.DANGER_ZONE_WIDTH / 2);
        const centerRight = width * (0.5 + CONFIG.DANGER_ZONE_WIDTH / 2);

        detections.forEach(det => {
            const [x, y, w, h] = det.bbox;
            const cx = x + w/2;
            const cy = y + h/2;
            const relArea = (w * h) / (video.videoWidth * video.videoHeight); // Use video dims for consistent area
            
            // Map video coords to canvas if needed (usually handled by CSS scaling, but bbox is video-relative)
            // We'll normalize for logic
            
            let threat = 0;
            let pos = "SIDE";

            if (cx > centerLeft && cx < centerRight) {
                pos = "CENTER";
                if (relArea > CONFIG.CRITICAL_AREA) threat = 4;
                else if (relArea > CONFIG.HIGH_AREA) threat = 3;
                else if (relArea > CONFIG.MEDIUM_AREA) threat = 2;
                else threat = 1;
            } else {
                if (relArea > CONFIG.HIGH_AREA) threat = 2; // Close but side
            }
            
            // Boost threat for vulnerable road users
            if (['person', 'bicycle', 'dog', 'horse'].includes(det.class) && pos === "CENTER" && threat > 0) {
                threat = Math.min(threat + 1, 4);
            }

            det.threatLevel = threat;
            det.relArea = relArea;
            
            if (threat > maxThreat) {
                maxThreat = threat;
                criticalObj = det;
            }
        });

        // Generate Instruction
        let main = "CLEAR";
        let sub = "Road ahead is clear";
        let color = COLORS.CYAN;

        if (maxThreat >= 4) {
            main = "âš  BRAKE";
            sub = `Collision Warning: ${criticalObj.class.toUpperCase()}`;
            color = COLORS.RED;
        } else if (maxThreat === 3) {
            main = "SLOW DOWN";
            sub = `Approaching ${criticalObj.class}`;
            color = COLORS.ORANGE;
        } else if (maxThreat === 2) {
            main = "CAUTION";
            sub = `Traffic Ahead`;
            color = COLORS.YELLOW;
        }

        return { main, sub, color, maxThreat };
    }

    function updateInstruction(analysis) {
        // Simple smoothing
        if (analysis.maxThreat >= 3) {
            // Instant update for danger
            currentInstruction = analysis;
        } else {
            // Slight delay/hysteresis could be added here, but direct is fine for mobile
            currentInstruction = analysis;
        }
    }

    // --- Rendering ---

    function drawRoadOverlay() {
        const w = canvas.width;
        const h = canvas.height;
        const cy = h / 2;
        
        // Draw static perspective lines (Sci-fi road)
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(0, 210, 255, 0.3)';
        ctx.lineWidth = 2;
        // Left line
        ctx.moveTo(w * 0.45, cy);
        ctx.lineTo(0, h);
        // Right line
        ctx.moveTo(w * 0.55, cy);
        ctx.lineTo(w, h);
        ctx.stroke();

        // Center crosshair
        ctx.strokeStyle = COLORS.CYAN;
        ctx.lineWidth = 1;
        const size = 20;
        ctx.beginPath();
        ctx.moveTo(w/2 - size, cy);
        ctx.lineTo(w/2 + size, cy);
        ctx.moveTo(w/2, cy - size);
        ctx.lineTo(w/2, cy + size);
        ctx.stroke();
    }

    function drawDetections(detections) {
        // Scale factors
        const scaleX = canvas.width / video.videoWidth;
        const scaleY = canvas.height / video.videoHeight;

        detections.forEach(det => {
            const [x, y, w, h] = det.bbox;
            const sx = x * scaleX;
            const sy = y * scaleY;
            const sw = w * scaleX;
            const sh = h * scaleY;

            let color = COLORS.CYAN;
            if (det.threatLevel === 4) color = COLORS.RED;
            else if (det.threatLevel === 3) color = COLORS.ORANGE;
            else if (det.threatLevel === 2) color = COLORS.YELLOW;
            else if (det.class === 'person') color = '#ff00ff';

            // Box
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.strokeRect(sx, sy, sw, sh);

            // Label Background
            ctx.fillStyle = color;
            const label = `${det.class.toUpperCase()} ${(det.score*100).toFixed(0)}%`;
            const textWidth = ctx.measureText(label).width;
            
            ctx.fillRect(sx, sy - 20, textWidth + 10, 20);
            
            // Label Text
            ctx.fillStyle = '#000';
            ctx.font = 'bold 12px sans-serif';
            ctx.fillText(label, sx + 5, sy - 5);

            // Distance Arc (Fake distance based on position)
            if (det.threatLevel > 1) {
                const bottomY = sy + sh;
                ctx.beginPath();
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.arc(canvas.width/2, bottomY, 10 + (sw/4), Math.PI, 0); // Simple arc visualization
                ctx.stroke();
            }
        });
    }

    function drawHUD(analysis) {
        const w = canvas.width;
        const h = canvas.height;

        // Top Bar
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(0, 0, w, 60);
        
        ctx.fillStyle = COLORS.CYAN;
        ctx.font = '14px monospace';
        ctx.fillText("AI DRIVING ASSISTANT", 20, 35);
        
        ctx.fillStyle = fps > 20 ? COLORS.GREEN : COLORS.RED;
        ctx.textAlign = 'right';
        ctx.fillText(`FPS: ${fps.toFixed(0)}`, w - 20, 35);

        // Bottom Panel
        const panelH = 100;
        ctx.fillStyle = 'linear-gradient(to top, rgba(0,0,0,0.9), transparent)'; // Not supported in canvas fillStyle directly like CSS, approximating
        ctx.fillStyle = 'rgba(0,0,0,0.8)';
        ctx.fillRect(0, h - panelH, w, panelH);
        
        // Dynamic Border
        ctx.strokeStyle = analysis.color;
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(0, h - panelH);
        ctx.lineTo(w, h - panelH);
        ctx.stroke();

        // Main Instruction
        ctx.textAlign = 'center';
        ctx.fillStyle = analysis.color;
        ctx.font = 'bold 36px sans-serif';
        // Add glow
        ctx.shadowColor = analysis.color;
        ctx.shadowBlur = 10;
        ctx.fillText(currentInstruction.main, w/2, h - 55);
        ctx.shadowBlur = 0;

        // Sub Text
        ctx.fillStyle = COLORS.WHITE;
        ctx.font = '16px sans-serif';
        ctx.fillText(currentInstruction.sub, w/2, h - 25);
    }

    // Start
    init();

</script>
</body>
</html>
